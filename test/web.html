<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器 | xx的博客</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="./2.jpg">
    <meta name="description" content="Welcome">
    <link rel="preload" href="/assets/css/0.styles.8b57ca07.css" as="style"><link rel="preload" href="/assets/js/app.b7abec6d.js" as="script"><link rel="preload" href="/assets/js/2.abe78d93.js" as="script"><link rel="preload" href="/assets/js/6.d1da093d.js" as="script"><link rel="preload" href="/assets/js/5.f990928a.js" as="script"><link rel="prefetch" href="/assets/js/10.9cf6598d.js"><link rel="prefetch" href="/assets/js/11.df34b82f.js"><link rel="prefetch" href="/assets/js/12.7fb2abf1.js"><link rel="prefetch" href="/assets/js/13.d1e87d6e.js"><link rel="prefetch" href="/assets/js/14.cd14ebb0.js"><link rel="prefetch" href="/assets/js/15.c890b1b1.js"><link rel="prefetch" href="/assets/js/16.8bda8f59.js"><link rel="prefetch" href="/assets/js/17.271cb451.js"><link rel="prefetch" href="/assets/js/18.a8bc42d5.js"><link rel="prefetch" href="/assets/js/19.865cf1bf.js"><link rel="prefetch" href="/assets/js/20.f61f8be2.js"><link rel="prefetch" href="/assets/js/21.ec8aee77.js"><link rel="prefetch" href="/assets/js/22.d64a6ba2.js"><link rel="prefetch" href="/assets/js/23.2fe942e0.js"><link rel="prefetch" href="/assets/js/24.2cb8cadf.js"><link rel="prefetch" href="/assets/js/25.e14bc8c3.js"><link rel="prefetch" href="/assets/js/26.9216a8e7.js"><link rel="prefetch" href="/assets/js/3.3faae2d7.js"><link rel="prefetch" href="/assets/js/4.be82c51c.js"><link rel="prefetch" href="/assets/js/7.59fc17b1.js"><link rel="prefetch" href="/assets/js/8.220bb62b.js"><link rel="prefetch" href="/assets/js/9.28a30f0e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8b57ca07.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">xx的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/reading/" class="nav-link">
  最近阅读
</a></div><div class="nav-item"><a href="/test/" class="nav-link router-link-active">
  面试题
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于我
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="联系方式" class="dropdown-title"><span class="title">联系方式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/ins/" class="nav-link">
  Ins
</a></li><li class="dropdown-item"><!----> <a href="/wechat/" class="nav-link">
  微信
</a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/xuxin2019f" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gittee
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/xuxin2019-f" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/reading/" class="nav-link">
  最近阅读
</a></div><div class="nav-item"><a href="/test/" class="nav-link router-link-active">
  面试题
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于我
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="联系方式" class="dropdown-title"><span class="title">联系方式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/ins/" class="nav-link">
  Ins
</a></li><li class="dropdown-item"><!----> <a href="/wechat/" class="nav-link">
  微信
</a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/xuxin2019f" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gittee
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/xuxin2019-f" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/test/" aria-current="page" class="sidebar-link">CSS 相关</a></li><li><a href="/test/aboutHtml.html" class="sidebar-link">HTML 相关</a></li><li><a href="/test/aboutjs.html" class="sidebar-link">js 相关</a></li><li><a href="/test/web.html" aria-current="page" class="active sidebar-link">浏览器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/web.html#从输入-url-到页面显示的经历过程" class="sidebar-link">从输入 url 到页面显示的经历过程</a></li><li class="sidebar-sub-header"><a href="/test/web.html#浏览器缓存" class="sidebar-link">浏览器缓存</a></li><li class="sidebar-sub-header"><a href="/test/web.html#浏览器存储" class="sidebar-link">浏览器存储</a></li><li class="sidebar-sub-header"><a href="/test/web.html#浏览器内核" class="sidebar-link">浏览器内核</a></li><li class="sidebar-sub-header"><a href="/test/web.html#跨域" class="sidebar-link">跨域</a></li></ul></li><li><a href="/test/webpack.html" class="sidebar-link">webpack</a></li><li><a href="/test/safety.html" class="sidebar-link">网络安全</a></li><li><a href="/test/aboutVue.html" class="sidebar-link">Vue 相关</a></li><li><a href="/test/aboutReact.html" class="sidebar-link">React 相关</a></li><li><a href="/test/math.html" class="sidebar-link">算法相关</a></li><li><a href="/test/git.html" class="sidebar-link">git 相关</a></li><li><a href="/test/aboutTs.html" class="sidebar-link">关于 TS</a></li><li><a href="/test/test.html" class="sidebar-link">总结的面试题</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="浏览器"><a href="#浏览器" class="header-anchor">#</a> 浏览器</h1> <h2 id="从输入-url-到页面显示的经历过程"><a href="#从输入-url-到页面显示的经历过程" class="header-anchor">#</a> 从输入 url 到页面显示的经历过程</h2> <ul><li>输入地址过程中浏览器的智能查询来匹配</li> <li>输入完成后开始解析 url 获取协议、主机、端口、path，组装 HTTP 请求报文</li> <li>查找 ip 地址（DNS 解析）
<img src="/assets/img/DNS.a5dcaa59.png" alt="DNS解析">
解析域名:首先在本地 hosts 文件中查询是否有和这个域名对应的 ip 关系规则，如果有直接用；如果没有，浏览器发起<strong>DNS 请求到本地 DNS 服务器</strong>，开始查询，进行<strong>递归查询</strong>，如果本地<strong>DNS 服务器的缓存</strong>有这条规则，则直接用，如果没有，向 DNS 根服务器进行<strong>迭代查询</strong></li> <li>建立服务器 TCP/IP 连接（三次握手进行连接），开始 HTTP 请求
拿到 ip 地址后，发起 HTTP 请求，<strong>客户端发起 TCP 连接请求，建立 TCP/IP 连接</strong>，<strong>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。（即 TCP 链接建立后才发送 HTTP 请求</strong></li> <li>可能涉及到重定向
如果存在网站调整，网页被移到新的地址，或者是网页扩展名改变了，又比如我们搜索的是 baidu.com，其实要访问的是 www.baidu.com，这个时候服务端会响应 301 永久重定向响应</li></ul> <p>这里有涉及到 301 和 302 状态码的区别：301 是永久重定向，302 是临时重定向（302 又在 http1.1 中由于幂等操作分为 303 和 307,303 代表不考虑非幂等操作，直接以 get 访问 location 的地址，307 要以 post 重新请求 location 的地址）</p> <ul><li><strong>客户端向重定向发起 HTTP 请求（请求报文），大网站涉及到 nginx 反向代理，再分配给真正的服务器（即可能存在服务器将请求转发的过程）</strong></li> <li>服务器解析请求报文，检查 HTTP 请求头中是否<strong>包含缓存验证信息</strong>，<strong>如果验证缓存新鲜，则返回 304 状态码，如果缓存不新鲜需要更新，返回 200 状态码</strong></li> <li>服务器处理程序读取完整请求并准备 HTTP 响应，可能有查询数据库等操作，<strong>然后服务器将响应报文通过 TCP 连接发送回浏览器</strong></li> <li>浏览器接收到 HTTP 响应后根据情况选择关闭 TCP 连接或保留重用，如果关闭执行 TCP 四次挥手：</li> <li><strong>TCP 四次挥手，释放连接（http1.0）</strong></li> <li>浏览器检查响应状态码是否为 1XX，3XX， 4XX， 5XX，这些情况处理与 2XX 不同；</li> <li><strong>如果资源可缓存，进行缓存</strong></li> <li><strong>对响应进行解码（例如 gzip 压缩）</strong></li> <li>根据资源类型决定如何处理，假设资源为 HTML 文档：解析将服务端响应的 html 文件解析并渲染 HTML 页面（自上而下）不同浏览器内核渲染稍有不同，以 webkit 为例：
<strong>先解析 html 构建 dom 树；再解析 css 构建 css 规则树；执行 js 代码；（这三者没有严格的先后顺序）dom 树和 css 规则树构建渲染树；对这个渲染树中的所有盒模型进行大小计算、确认布局，这个过程称为 reflow 或 layout；最后进行渲染，称为 repain；</strong></li> <li>当解析 HTML 的时候发现新的资源（link、script、img、iframe、video、audio 等带有 href 或 src 这类外部资源链接的属性的资源标签，注意 a 标签不会），<strong>浏览器发起新一轮的请求</strong></li> <li>显示页面（HTML 解析过程中会初步显示页面）</li></ul> <h2 id="浏览器缓存"><a href="#浏览器缓存" class="header-anchor">#</a> 浏览器缓存</h2> <h3 id="面试题：在-css-js-代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次-js-请求一般情况下有哪些地方会有缓存处理？（这些缓存都是为了解决网络延迟，提高用户体验"><a href="#面试题：在-css-js-代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次-js-请求一般情况下有哪些地方会有缓存处理？（这些缓存都是为了解决网络延迟，提高用户体验" class="header-anchor">#</a> 面试题：在 css/js 代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理？（<strong>这些缓存都是为了解决网络延迟，提高用户体验</strong></h3> <p><strong>浏览器缓存，<code>dns</code>缓存，<code>cdn</code>缓存，服务器缓存</strong> <strong>dns 缓存</strong>：指在 dns 返回正确的 pi 之后，系统会将这个结果临时储存起来，并为它设定一个失效时间，在失效时间之内，浏览器再次访问这个网站时，系统会直接从电脑本地的 dns 缓存中找到这个 ip 地址，不必再去询问 dns 服务器，变相加速了网址的解析
<strong>cdn 缓存</strong>：为了提高距离较远的地区的用户的访问速度，创建了一些最接近用户网络的边缘服务器，将文件缓存在这些边缘服务器上，这就是 CDN 缓存
<strong>浏览器缓存</strong>:
浏览器启用缓存的优点：<strong>减少页面加载速度，减小服务器负载</strong></p> <p>浏览器是否使用缓存，缓存多久，是由服务器控制的，当浏览器请求一个网页或其他资源时，服务器返回的响应头部分的某些字段指明了有关缓存的关键信息</p> <p>大致流程：</p> <p>发送请求后，要先 1.判断浏览器内是否有上次请求后留下的缓存，如果存在缓存，2.再判断是否命中强缓存（<strong>浏览器第一次跟服务器请求资源时，服务器在返回资源的同时，会在 response 的 header 中加上 Expires 或 catch-control 的 header</strong>）：</p> <ul><li>判断是否有 Catch-Control：以秒为单位（表示从第一次请求开始到截止时间的总共时间，当浏览器再次请求这个资源时，超过这个时间，就无法命中强缓存了）</li> <li>判断是否有 Expires：如果没有 catch-control，则查找是否有 expires，表示资源过期的截止时间，超过这个截止时间，无法命中强缓存</li></ul> <p><strong>如果存在强缓存，则返回状态码 200，直接用缓存内容，不会发请求到服务端</strong></p> <p>3.如果没有强缓存，则发送请求到服务端查看是否存在协商缓存：</p> <ul><li>发送<strong>If-None-Match</strong>请求，判断<strong>Etag</strong>是否相同（如果资源不变，Etag 不发生改变），如果相同，则返回状态码<strong>304 Not Modified</strong>，直接用本地缓存</li> <li>如果没有 Etag，则查找是否有<strong>Last-Modefied</strong>的 header，有则发送<strong>If-Modified-Since</strong>请求（内容就是 Last-Modefied 的值），服务器根据这个请求和服务器现在自身的资源做比较，判断是否资源发生了更新，如果没有变化，返回状态码<strong>304 Not Modified</strong>，如果有变化，则客户端要从服务端请求资源</li></ul> <p>上面两个的区别是：如果没有改变返回 304，response header 还会返回 Etag（就算是相同的），但是不会返回 Last Modefied（相同则直接保存的 Last Modefied）</p> <h2 id="浏览器存储"><a href="#浏览器存储" class="header-anchor">#</a> 浏览器存储</h2> <h4 id="_1-cookie-与-session"><a href="#_1-cookie-与-session" class="header-anchor">#</a> 1.cookie 与 session</h4> <p>cookie 的作用是维持状态（因为 http 是无状态的，一次连接后就关闭了），产生 cookie 的过程是：客户端第一次发送请求时，服务端检查请求头中是否有 cookie，如果没有，则为这个用户生成一个 session 和 sessionid，并以 sessionid 为值生成 cookie 作为响应头数据返回给客户端，在客户端保存着 cookie，以后<strong>客户端每次发请求都会携带着这个 cookie</strong>，以便服务端作身份验证。**即 cookie 是服务端产生保存在客户端的，session 是保存在服务端的。**应用场景：用户登录、购物车购物</p> <p>生成 cookie 的方式</p> <ul><li>在响应头中 set-cookie（还可以设置 expires 过期时间）</li> <li>js 中通过 document.cookie 进行读（indexOf）写</li></ul> <p>​ cookie 的缺点：</p> <ul><li><p>**同源限制（重要）**https://www.cnblogs.com/liaojie970/p/7606168.html</p> <p><strong><em>即 cookie 只能在同源页面下相互共享，相同的还有 localStorage 和 indexDB，这样做是为了防止恶意网站窜取 cookie，保证用户安全</em></strong></p></li> <li><p>​ <strong>cookie 是明文携带的，安全性低，容易被攻击（比如 XSS 攻击和 CSRF 攻击）</strong>，所以只能放不敏感的信息，敏感信息还是只能存在 session 中，但这样会增加服务器负担，所以高访问量的网址不会选择 session 考虑性能还是只能选择 cookie</p></li> <li><p>cookie 可携带体积很小，只有 4k，原则上 cookie 携带量不能超过 20 条</p></li> <li><p>存在 cookie 后客户端每次发送请求都会携带 cookie，在许多不需要应用到 cookie 的场合会造成严重的资源浪费</p></li> <li><p>cookie 可以被禁用删除和篡改，当被禁用时传递 sessionid 给服务端的方式是：</p> <ul><li>重写 url：即在 url 后写 sessionid=。。。。。。</li> <li>在表单里加一个 type=hidden 的 input 框，value 为 sessionid</li></ul></li></ul> <h4 id="_2-web-storage"><a href="#_2-web-storage" class="header-anchor">#</a> 2.web Storage</h4> <p>为了解决 cookie 存在的问题，html5 提出了 web Storage，分为 localStorage 和 sessionStorage，<strong>这两个都不需要向服务端发送请求，都是存储在本地的，且存储体积更大 5-10M 左右</strong></p> <ul><li>localStorage</li></ul> <p>​ 永久存储在本地，<strong><em>所有同源页面下资源共享（同 cookie）</em></strong>，<strong>即可以跨页面跨窗口</strong>，读写方法：</p> <p>localStorage.setItem('key','value')</p> <p>localStorage.getItem('key')</p> <ul><li><p>sessionStorage</p> <p>存储时间为一次会话（即一直到该窗口关闭为止），<strong>不能跨窗口（但可以刷新跨页面），当你开启新的会话时，它也需要相应的更新或释放。比如微博的 sessionStorage 就主要是存储你本次会话的浏览足迹</strong></p> <p>读写方法：</p> <p>sessionStorage.setItem('key','value')</p> <p>sessionStorage.getItem('key')</p></li></ul> <p><strong>web Storage 是 cookie 的扩展，但是也不能支持大数据的存储</strong></p> <h4 id="_3-indexeddb"><a href="#_3-indexeddb" class="header-anchor">#</a> 3.indexedDB</h4> <p>IndexedDB 是一种低级 API，<strong>用于客户端存储大量结构化数据(包括文件和 blobs)</strong>。理论上来说，IndexedDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。</p> <p>建立打开 IndexedDB ----<code>window.indexedDB.open(&quot;testDB&quot;)</code></p> <p>关闭 IndexedDB----<code>indexdb.close()</code></p> <p>删除 IndexedDB----<code>window.indexedDB.deleteDatabase(indexdb)</code></p> <h2 id="浏览器内核"><a href="#浏览器内核" class="header-anchor">#</a> 浏览器内核</h2> <p>浏览器内核主要分为渲染引擎和 js 引擎</p> <p>渲染引擎负责获取页面内容（html、xml、图像等），获取 css 样式，计算页面布局和盒子大小，渲染 dom 树和 css 规则树，再合并成渲染树实现渲染，不同的内核渲染的方式有所区别，对语法的解释也会有所不同</p> <p>js 引擎指的是解析和执行 JavaScript 来实现网页的动态效果</p> <p>常见的浏览器内核有：</p> <p>IE：trident ；chrome、safari、opera：webkit（blink）；firefox：gecko</p> <h2 id="跨域"><a href="#跨域" class="header-anchor">#</a> 跨域</h2> <p>产生跨域的原因是浏览器的同源政策，浏览器规定 ajax 请求必须在同源条件下进行（即请求地址与原地址的协议，域名，端口都相同），否则会发生拦截</p> <p>解决跨域的方法</p> <h4 id="jsonp"><a href="#jsonp" class="header-anchor">#</a> jsonp</h4> <p>jsonp 的原理是 script 标签的 src 属性是不受跨域限制的。具体操作方法是：将不同源的请求地址写在客户端的 script 标签中，并在客户端中定义一个全局函数，用于操作服务端返回来的数据，在服务端返回一个字符串，字符串内包含的是客户端定义的全局函数，服务端返回的数据写在这个函数的参数里</p> <div class="language-js extra-class"><pre class="language-js"><code>客户端：
 <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">'https://www.wq.com'</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

服务端  字符串里的函数名要和客户端定义的函数名一一对应
<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token string">'fn({name:'</span>zhangsan<span class="token string">',age:18})'</span>
res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
</code></pre></div><p>jsonp 的封装(<strong>实现 script 标签的动态添加</strong>)</p> <div class="language-js extra-class"><pre class="language-js"><code>期望的格式：
 <span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    url<span class="token operator">:</span><span class="token string">'http://localhost:80/xxx'</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span><span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">'张三'</span><span class="token punctuation">,</span>age<span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">success</span><span class="token operator">:</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">datas</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>datas<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span>
    <span class="token keyword">var</span> params <span class="token operator">=</span> <span class="token string">''</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> attr <span class="token keyword">in</span> options<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
        params <span class="token operator">+=</span> <span class="token string">'&amp;'</span><span class="token operator">+</span>attr<span class="token operator">+</span><span class="token string">'='</span><span class="token operator">+</span>options<span class="token punctuation">.</span>data<span class="token punctuation">[</span>attr<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> fnname <span class="token operator">=</span> <span class="token string">'jsonp'</span><span class="token operator">+</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span>
    <span class="token comment">//创建全局函数</span>
    window<span class="token punctuation">[</span>fnname<span class="token punctuation">]</span><span class="token operator">=</span>options<span class="token punctuation">.</span>success
    script<span class="token punctuation">.</span>src <span class="token operator">=</span> options<span class="token punctuation">.</span>url<span class="token operator">+</span><span class="token string">'?callback='</span><span class="token operator">+</span>fnname<span class="token operator">+</span>params
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span>
    script<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>jsonp 缺点：因为 script 标签的请求都是 get 请求，所以只能局限于 get 请求</strong></p> <h4 id="cors"><a href="#cors" class="header-anchor">#</a> CORS</h4> <p>原理是在服务器端对请求响应做出检查（分析出简单请求和预检请求），并相应的做出响应请求头的处理，从而允许跨域请求</p> <div class="language- extra-class"><pre class="language-text"><code>// 原生
app.use((req,res,next)=&gt;{
  res.header('Access-Control-Allow-Origin','允许请求的地址，如果写*则代表允许所有地址请求，但涉及是否带cookie时不允许写*')
  res.header('Access-Control-Allow-Method','GET','POST',,,,)
  res.header('Access-Control-Allow-Credentials',true)
  next()
})
</code></pre></div><p><strong>注意：CORS 有简单请求和预检请求</strong></p> <p>简单请求：请求方式只能是 get、post、head，并且不能自定义响应头，content-type 也不能是 application/json。</p> <p>预检请求：请求方式是别的，自定义了 headers，content-type 是 application/json</p> <p>详细见 Node/note/03-网络编程</p> <h4 id="客户端正向代理"><a href="#客户端正向代理" class="header-anchor">#</a> 客户端正向代理</h4> <p>由于跨域的限制只存在于浏览器，服务端是不存在这个限制的</p> <p>原理是<strong>请求同源</strong>的服务器，通过该服务器<strong>转发</strong>请求至目的服务器，得到结果再<strong>转发</strong>给前端</p> <p><strong>即代理服务器假装自己是客户端，去请求真实的服务器，然后返回数据给客户端</strong></p> <p>在 node 中可以使用第三方模块 http-proxy-middleware（<strong>vuecli，webpack 都是用的这个包</strong>）</p> <div class="language- extra-class"><pre class="language-text"><code>var proxy = require('http-proxy-middleware');
var options = {
        target: 'http://localhost:8088', // 目标主机
        changeOrigin: true,               // 需要虚拟主机站点
    };
var exampleProxy = proxy(options);  //开启代理功能，并加载配置
app.use('/', exampleProxy);//对地址为’/‘的请求全部转发
</code></pre></div><p>在 vue-cli 中配置：</p> <p>vue-cli2.x 在 config/index.js 下</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
  dev:{
    proxyTable: {
       '/api':{
          target:'xxxx',
          secure:true //是否开启https请求
          changeOrigin:true //是否跨域，必须设置，开启代理后在本地会创建一个虚拟服务端发送请求
          pathRewrite:{'^/api':''}//路径重写
          比如http请求本来是axios.get(‘http://10.18.110.107/tasktime’,{params:{num:12})
就可以写成axios.get(’/api/tasktime’,{params:{num:12}) 实现跨域
       }
    }
  }
}
</code></pre></div><p>vue-cli 3.x</p> <div class="language- extra-class"><pre class="language-text"><code>// vue.config.js 如果没有就新建
module.exports = {
   devServer: {
   port: 8000,
   proxy: {
     &quot;/api&quot;: {
     target: &quot;http://localhost:8080&quot;
     }
   }
 }};
</code></pre></div><p>在 nuxt.js 中配置反向接口：在 nuxt.config.js 下配置</p> <div class="language- extra-class"><pre class="language-text"><code> proxy:{
    '/api/' :{
      // 转发
      target:'http://localhost:7003',
      secure:false,
      pathRewrite:{
        '^/api':&quot;&quot;
      }
    }
  }
</code></pre></div><p>webpack（4.x）</p> <p>在 webpack 中可以配置 proxy 来快速获得接口代理的能力</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
   ....
   devServer:{
      port:8000, //当前前端端口
      proxy:{
        '/api':{
           target:'http://localhost:8080',
           pathRewrite:{
             '^/api':''
           }
        }
      }
   }
}
</code></pre></div><h4 id="服务端反向代理-nginx"><a href="#服务端反向代理-nginx" class="header-anchor">#</a> 服务端反向代理(Nginx)</h4> <p>代理服务器对于客户端来说就是真实的服务器，当客户端请求之后，这个代理服务器会分发请求</p> <div class="gitalk-container"><div id="gitalk-container"></div></div> <div class="gitalk-container"><div id="gitalk-container"></div></div> <div class="gitalk-container"><div id="gitalk-container"></div></div> <div class="gitalk-container"><div id="gitalk-container"></div></div> <div class="gitalk-container"><div id="gitalk-container"></div></div> <div class="gitalk-container"><div id="gitalk-container"></div></div> <div class="gitalk-container"><div id="gitalk-container"></div></div> <div class="gitalk-container"><div id="gitalk-container"></div></div> <div class="gitalk-container"><div id="gitalk-container"></div></div> <div class="gitalk-container"><div id="gitalk-container"></div></div> <div class="gitalk-container"><div id="gitalk-container"></div></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/test/aboutjs.html" class="prev">
        js 相关
      </a></span> <span class="next"><a href="/test/webpack.html">
        webpack
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.b7abec6d.js" defer></script><script src="/assets/js/2.abe78d93.js" defer></script><script src="/assets/js/6.d1da093d.js" defer></script><script src="/assets/js/5.f990928a.js" defer></script>
  </body>
</html>
