(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{499:function(t,i,a){"use strict";a.r(i);var _=a(59),e=Object(_.a)({},(function(){var t=this,i=t.$createElement,a=t._self._c||i;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"git-相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git-相关"}},[t._v("#")]),t._v(" git 相关")]),t._v(" "),a("h2",{attrs:{id:"git-分区："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git-分区："}},[t._v("#")]),t._v(" git 分区：")]),t._v(" "),a("ol",[a("li",[t._v("工作区：是我们直接编辑的地方，例如 Android Studio 打开的项目，记事本打开的文本等，肉眼可见，直接操作。")]),t._v(" "),a("li",[t._v("暂存区：数据暂时存放的区域，可在工作区和版本库之间进行数据的友好交流。")]),t._v(" "),a("li",[t._v("版本库：放已经提交的数据，push 的时候，就是把这个区的数据 push 到远程仓库了。")])]),t._v(" "),a("h2",{attrs:{id:"_1-拉取远程仓库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-拉取远程仓库"}},[t._v("#")]),t._v(" 1.拉取远程仓库")]),t._v(" "),a("ol",[a("li",[t._v("git init")]),t._v(" "),a("li",[t._v("git add .")]),t._v(" "),a("li",[t._v("git commit -m 'first commit'")]),t._v(" "),a("li",[t._v("git remote add origin + 远程仓库地址")]),t._v(" "),a("li",[t._v("如果仓库初始化 readme 了：git pull --rebase origin master\n如果在初始化 readme 情况下不 pull，会出现 github 拒绝更新的情况：因为我们在 GitHub 上新建仓库时一般会选择生成一个 README.md 的说明文档，因此我们必须使用以下命令将 README.md 下载到我们的本地仓库再使用 git push -u origin master 命令就能成功将代码上传到 GitHub 的远程仓库\n注意：git pull --rebase 用于解决分叉")]),t._v(" "),a("li",[t._v("git push -u origin master")])]),t._v(" "),a("p",[t._v("删除绑定的远程仓库： git remote rm origin")]),t._v(" "),a("h3",{attrs:{id:"git-commit-m-和-git-commit-am-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git-commit-m-和-git-commit-am-的区别"}},[t._v("#")]),t._v(" git commit -m 和 git commit -am 的区别")]),t._v(" "),a("p",[t._v("https://www.cnblogs.com/smile-fanyin/p/10827438.html\n总的来说 git add 会将文件标记为已追踪并添加到暂存区，git commit -m 用于提交暂存区的文件，git commit -am 用于提交已追踪的文件(即文件要有被 add 过的历史)")]),t._v(" "),a("h2",{attrs:{id:"_2-分支"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-分支"}},[t._v("#")]),t._v(" 2.分支")]),t._v(" "),a("ul",[a("li",[t._v("git branch： 查看分支")]),t._v(" "),a("li",[t._v("git branch 分支名称：创建分支")]),t._v(" "),a("li",[t._v("git checkout 分支名称: 切换分支**(在切换分支时，必须将所有改动进行提交，否则会出现问题)**\n在分支 commit 后，执行 git push origin 分支名称：实现将该分支代码提交到远程仓库")]),t._v(" "),a("li",[t._v("git log 查看提交历史")]),t._v(" "),a("li",[t._v("git branch -d 分支名称:删除分支")])]),t._v(" "),a("h3",{attrs:{id:"！！合并分支"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#！！合并分支"}},[t._v("#")]),t._v(" ！！合并分支")]),t._v(" "),a("h4",{attrs:{id:"_1-git-merge"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-git-merge"}},[t._v("#")]),t._v(" 1.git merge")]),t._v(" "),a("p",[t._v("git merge 来源分支:\n将某一个分支的 commit 合并到当前分支(使用场景：当前分支上的工作已经完成，可以将当前分支合并到其他分支上) 比如将开发分支合并到主分支上，先 git checkout master 切换到主分支上,再 git merge develop 将开发分支合并到主分支上。"),a("strong",[t._v("注意，此时仍然存在开发分支，还可以在开发分支上开发新功能")])]),t._v(" "),a("h4",{attrs:{id:"_2-git-rebase"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-git-rebase"}},[t._v("#")]),t._v(" 2.git rebase")]),t._v(" "),a("p",[t._v("git rebase 操作实际上是将当前执行 rebase 分支的所有基于原分支提交点之后的 commit 打散成一个一个的 patch，并重新生成一个新的 commit hash 值，再次基于原分支目前最新的 commit 点上进行提交，并不根据两个分支上实际的每次提交的时间点排序，rebase 完成后，切到基分支进行合并另一个分支时也不会生成一个新的 commit 点，可以保持整个分支树的完美线性")]),t._v(" "),a("ol",[a("li",[t._v("首先要创建一个新的分支，并且 git push origin 分支名称确保远程仓库也建立了对应分支")]),t._v(" "),a("li",[t._v("在分支内提交")]),t._v(" "),a("li",[t._v("在分支内执行 git rebase master (如果此时 master 也有了新的提交，即出现了分叉，将会出现冲突，手动解决冲突后 git add . ,然后 git rebase --continue 来继续操作 rebase)")]),t._v(" "),a("li",[t._v("切换回 master 分支，执行 git merger 新的分支名称\n参考：\nhttps://www.jianshu.com/p/6960811ac89c\nhttps://www.cnblogs.com/ludashi/p/8116434.html\n"),a("strong",[t._v("总结")])])]),t._v(" "),a("ul",[a("li",[t._v("git merge 操作合并分支会让两个分支的每一次提交都按照提交时间（并不是 push 时间）排序，并且会将两个分支的最新一次 commit 点进行合并成一个新的 commit，最终的分支树呈现非整条线性直线的形式")]),t._v(" "),a("li",[t._v("git rebase 操作实际上是将当前执行 rebase 分支的所有基于原分支提交点之后的 commit 打散成一个一个的 patch，并重新生成一个新的 commit hash 值，"),a("strong",[t._v("即 rebase 后提交分支内提交的 commit 的 hash 值也发生了变化")]),t._v("，再次基于原分支目前最新的 commit 点上进行提交，并不根据两个分支上实际的每次提交的时间点排序，"),a("strong",[t._v("rebase 完成后，切到基分支进行合并另一个分支时也不会生成一个新的 commit 点，可以保持整个分支树的完美线性")])])]),t._v(" "),a("h4",{attrs:{id:"cherry-pick"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cherry-pick"}},[t._v("#")]),t._v(" cherry-pick")]),t._v(" "),a("p",[t._v("使用该命令可以将任意的 commit 通过其 commit 号将其合并到你想要的分支上。\n具体操作：git cherry-pick <希望合并的 commit 的 hash 值>\n然后将这些提交合并到 master 分支上。这些分支会根据 cherry-pick 的顺序进行 merge，"),a("strong",[t._v("每次 merge 都会形成一个新的提交。与 rebase 命令不同，虽然会产生一个新的提交，而之前的提交是不变的")]),t._v("。\n如果产生冲突：比如有 3 次提交，每次都要解决后再 git add .,然后 git cherry-pick --continue 进行下一个提交，直到解决了所有冲突并所有的 commit 被合并完成。")]),t._v(" "),a("h2",{attrs:{id:"_3-暂时保存更改"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-暂时保存更改"}},[t._v("#")]),t._v(" 3.暂时保存更改")]),t._v(" "),a("p",[t._v("在 git 中，可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的工作副本，临时转向其他工作。")]),t._v(" "),a("p",[t._v("使用场景：分支临时切换**（即突然有其他事情要做，但是现在这个分支上的事情没做完，不想提交到暂存区和 git 仓库，则用 git stash 剪切掉该分支的所有内容，当回到该分支时，再用 git stash pop 来恢复这些内容继续编辑）**")]),t._v(" "),a("ul",[a("li",[t._v("存储临时改动："),a("code",[t._v("git stash")])]),t._v(" "),a("li",[t._v("恢复改动："),a("code",[t._v("git stash pop")])])]),t._v(" "),a("h2",{attrs:{id:"_4-解决冲突"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-解决冲突"}},[t._v("#")]),t._v(" 4.解决冲突")]),t._v(" "),a("p",[t._v("在多人同时开发一个项目时，如果两个人修改了同一个文件的同一个地方，就会发生冲突。冲突需要人为解决。\nHEAD 冲突开始， 结尾冲突结束\n假设 A 端先提交，为了解决冲突，B 端要先将远程仓库的最新版本 pull 回本地，然后把 1.3.5 行冲突删除，再更新到远程仓库。")]),t._v(" "),a("h2",{attrs:{id:"_5-忽略清单"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-忽略清单"}},[t._v("#")]),t._v(" 5.忽略清单")]),t._v(" "),a("p",[t._v("将不需要被 git 管理的文件（比如不需要修改的文件，如 node_modules）名字添加到此文件中，在执行 git 命令的时候，git 就会忽略这些文件。")]),t._v(" "),a("p",[t._v("git 忽略清单文件名称："),a("strong",[t._v(".gitignore")])]),t._v(" "),a("p",[a("strong",[t._v("例子：新建.gitignore 文件夹，然后在里面写上不想被管理的文件名，如 node_modules")])]),t._v(" "),a("p",[t._v("将工作目录中的文件全部添加到暂存区："),a("code",[t._v("git add .")])]),t._v(" "),a("h2",{attrs:{id:"_6-版本切换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-版本切换"}},[t._v("#")]),t._v(" 6.版本切换")]),t._v(" "),a("ol",[a("li",[t._v("git log 打印日志")]),t._v(" "),a("li",[t._v("首先，Git 必须知道当前版本是哪个版本，在 Git 中，用 HEAD 表示当前版本，也就是最新提交的版本，上一个版本就是 HEAD^， 上上一个版本就是 HEAD^^ ，当然往上 100 个版本写 100 个^比较容易数不过来，所以写成 HEAD~100")]),t._v(" "),a("li",[t._v("如果要回退到上一个版本：使用 git reset --hard HEAD^")]),t._v(" "),a("li",[t._v("如果多版本切换，使用 git reflog 命令查看之前经过的所有 commit 路径，复制其中的 commt_id 值，用 git reset --hard commt_id 进行切换。(即 HEAD 可以用来替换 commit_id，HEAD 指向的版本是当前版本，上一个版本就是 HEAD^ ，上上一个版本就是 HEAD^^ ，往上 100 个版本写成 HEAD~100。)")])]),t._v(" "),a("h2",{attrs:{id:"_7-关于-git-reset-的三种模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-关于-git-reset-的三种模式"}},[t._v("#")]),t._v(" 7.关于 git reset 的三种模式")]),t._v(" "),a("p",[t._v("https://www.jianshu.com/p/c2ec5f06cf1a")]),t._v(" "),a("ul",[a("li",[t._v("soft 与 hard 不同 soft 会保留工作目录，并把因为保留工作目录内容所带来的新的文件差异放入暂存区。")]),t._v(" "),a("li",[t._v("mixed(默认使用) 保留工作区，并清空暂存区")]),t._v(" "),a("li",[t._v("hard 重置暂存区和工作目录")])]),t._v(" "),a("comment"),t._v(" "),a("comment"),t._v(" "),a("comment"),t._v(" "),a("comment"),t._v(" "),a("comment"),t._v(" "),a("comment")],1)}),[],!1,null,null,null);i.default=e.exports}}]);